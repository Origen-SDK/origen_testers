<a class="anchor release_tag" name="v0_7_5"></a>
<h1><a href="#v0_7_5">Tag: v0.7.5</a></h1>

##### Branch: 'master'

##### by Priyavadan Kumar on 01-Jul-2016 15:05PM


Updates from Thao

<a class="anchor release_tag" name="v0_7_4"></a>
<h1><a href="#v0_7_4">Tag: v0.7.4</a></h1>

##### Branch: 'master'

##### by Priyavadan Kumar on 16-Jun-2016 13:15PM


Added Frequency Counter support for UltraFLEX.

<a class="anchor release_tag" name="v0_7_3"></a>
<h1><a href="#v0_7_3">Tag: v0.7.3</a></h1>

##### Branch: 'master'

##### by Ronnie Lajaunie on 15-Jun-2016 09:33AM


Minor update to smartest\_based\_tester to allow for lower-case naming of pin groups of size
1 (or more).

<a class="anchor release_tag" name="v0_7_2"></a>
<h1><a href="#v0_7_2">Tag: v0.7.2</a></h1>

##### Branch: 'master'

##### by Stephen McGinty on 09-Jun-2016 09:40AM


* Corrected formatting bug in (UltraFLEX) Levelset sheet creation (Aaron Burgmeier)
* Added a hook to allow 3rd party plugins that provide a tester driver, to easily 
  make their program generator API available to their user's interface:

~~~ruby
# Application interface
module MyApp
  class Interface
    # All interfaces should include this, adds the program generator APIs for all
    # platforms supported by OrigenTesters, and now also any platforms provided
    # by 3rd parties
    include OrigenTesters::ProgramGenerators
  end
end

# 3rd Party Plugin, this is the class that will be instantiated in the target/environment
module MyTester
 class Tester
   # By defining this constant OrigenTesters will load the API into the interface
   # whenever an instance of this class is the current tester loaded by the target 
   TEST\_PROGRAM\_GENERATOR = MyTester::Generator
  end
end

# 3rd Party Plugin, this implements the program generator API
module MyTester
  class Generator
    extend ActiveSupport::Concern

    included do
      include OrigenTesters::Interface  # adds the interface helpers/Origen hook-up
    end

    # This method will now be available within the above application interface
    def some\_api\_method
      # Generator some test program item
    end
  end
end
~~~

<a class="anchor release_tag" name="v0_7_1"></a>
<h1><a href="#v0_7_1">Tag: v0.7.1</a></h1>

##### Branch: 'master'

##### by Priyavadan Kumar on 27-May-2016 13:44PM


Updates to the UltraFLEX Interface to support a few extra features that were previously
not included.

<a class="anchor release_tag" name="v0_7_0"></a>
<h1><a href="#v0_7_0">Tag: v0.7.0</a></h1>

##### Branch: 'master'

##### by Stephen McGinty on 23-May-2016 03:22AM


Fixed bug from additional capture cycles being inserted into period levelled vector
on V93K, now works correctly like this:

~~~text
$tester.set\_timeset("fast", 40)
2.cycles                        #    fast   1 0 C 1 0
                                #    fast   1 0 C 1 0

$tester.level\_period = false  # Without levelling enabled
$tester.set\_timeset("slow", 80)
2.cycles                        #    slow   1 0 C 1 0
                                #    slow   1 0 C 1 0

$tester.level\_period = true   # With levelling enabled
$tester.set\_timeset("slow", 80)
2.cycles                        #    fast   1 0 X 1 0
                                #    fast   1 0 C 1 0
                                #    fast   1 0 X 1 0
                                #    fast   1 0 C 1 0
~~~

<a class="anchor release_tag" name="v0_7_0_pre0"></a>
<h2><a href="#v0_7_0_pre0">Tag: v0.7.0.pre0</a></h2>

##### Branch: 'master'

##### by Chris Nappi on 04-May-2016 10:59AM


Added check for size in header case change
Patch for operation on Windows
Corrected 'GlobalSpecs' output file for examples check
93K - Allow pingroups and aliases to have lower case letters
Updated sheet prefix for Global Specs
Added UFlex sheet generation support for Timeset Basic, Global Specs,â€¦

<a class="anchor release_tag" name="v0_6_2"></a>
<h1><a href="#v0_6_2">Tag: v0.6.2</a></h1>

##### Branch: 'master'

##### by Stephen McGinty on 08-Apr-2016 09:02AM


Minor patch to create the test program output directory if it doesn't exist

<a class="anchor release_tag" name="v0_6_1"></a>
<h1><a href="#v0_6_1">Tag: v0.6.1</a></h1>

##### Branch: 'master'

##### by Stephen McGinty on 31-Mar-2016 07:36AM


Added link? method to the common API (i.e. available on all tester objects) to check if
the current tester is an OrigenLink driver

<a class="anchor release_tag" name="v0_6_0"></a>
<h1><a href="#v0_6_0">Tag: v0.6.0</a></h1>

##### Branch: 'master'

##### by Stephen McGinty on 23-Mar-2016 12:57PM


Some major feature additions:

Completely overhauled test flow generator backend, which now fully supports the same test flow
source code rendering to J750, UltraFLEX and V93K.

Official documentation for this is still to follow, but for now see the comments in the
pull-request for some examples:
[PR \#3](https://github.com/Origen-SDK/origen_testers/pull/3)

Added generator APIs for UltraFLEX pinmaps, edgesets, timesets, levelsets, and AC and DC
spec sets (Aaron Burgmeier).

Again the documentation is still to come, but examples of using these APIs can be found
in
[lib/origen_testers/test/ultraflex_interface.rb](https://github.com/Origen-SDK/origen_testers/blob/master/lib/origen_testers/test/ultraflex_interface.rb)


<a class="anchor release_tag" name="v0_5_7"></a>
<h1><a href="#v0_5_7">Tag: v0.5.7</a></h1>

##### Branch: 'master'

##### by Stephen McGinty on 08-Mar-2016 06:54AM


* Added ATE\_Hardware Code and related syntatic sugar code for Origen Core \#7 (Scott Chen)
  * Minor Updates for Import\_chanmap method.
  * Added ATEHardware Class for PPMU/Supply spec look-up for Test Program Generation.  

~~~ruby
# Importing UltraFLEX tester config
$tester.import\_tester\_config('FT', "#{Origen.root}/spec/atehardware/CurrentConfig\_sample.txt")
$tester.default\_testerconfig                # => 'FT'
$tester.get\_tester\_instrument('FT', 1)      # => 'HSD-4G'
$tester.get\_instrument\_slots('FT', 'HSD-U') # => [12, 14, 15, 17, 20]

# Importing UltraFLEX channel map
$tester.import\_chanmap('FTx4', "#{Origen.root}/spec/atehardware/atehardware\_chanmap.txt")
$tester.default\_channelmap                      # => 'FTx4'
$tester.get\_tester\_channel('FTx4', :pin1, 0)    # => '14.ch28'
$tester.get\_tester\_channel('FTx4', :pin2, 3)    # => '20.ch231'
$tester.channelmap['FTx4'].size                 # => 4
$tester.merged\_channels('FTx4', :avdd, 1)       # => 'x2'
$tester.is\_hexvs\_plus('FT', 18)                 # => '+'
$tester.is\_vhdvs\_plus('FT', 0)                  # => '+'
$tester.is\_vhdvs\_hc('FTx4', :cvdd, 2)           # '\_HC'

# Retrieving ATEHardware data properly
$tester.ate\_hardware('HSD-M').ppmu.vclamp.min                 # => -2
$tester.ate\_hardware('HSD-4G').ppmu.measv.min                 # => -1
$tester.ate\_hardware('HSS-6G').ppmu.vclamp.max                # => 3.9
$tester.ate\_hardware('VSM').supply.forcev.max                 # => 4
$tester.ate\_hardware('VSMx2').supply.irange.max               # => 162
$tester.ate\_hardware('HexVS').supply.forcev.max               # => 5.5
$tester.ate\_hardware('HexVSx2').supply.filter                 # => 10\_000
$tester.ate\_hardware('HexVSx4').supply.bandwidth.size         # => 8
$tester.ate\_hardware('HexVSx6').supply.irange.size            # => 2
$tester.ate\_hardware('HexVS+').supply.forcev.max              # => 5.5
$tester.ate\_hardware('HexVS+x2').supply.filter                # => 10\_000
$tester.ate\_hardware('HexVS+x4').supply.bandwidth.size        # => 8
$tester.ate\_hardware('HexVS+x6').supply.irange.size           # => 2
$tester.ate\_hardware('HDVS1').supply.sink\_fold\_i.min          # => 5.mA
$tester.ate\_hardware('HDVS1x2').supply.meter\_vrange           # => 7
$tester.ate\_hardware('HDVS1x4').supply.source\_fold\_i.max      # => 4
$tester.ate\_hardware('VHDVS').supply.irange.size              # => 6
$tester.ate\_hardware('VHDVS\_HC').supply.sink\_fold\_t.max       # => 2
$tester.ate\_hardware('VHDVSx2').supply.meter\_vrange           # => 18
$tester.ate\_hardware('VHDVS\_HCx2').supply.forcev.min          # => -2
$tester.ate\_hardware('VHDVS\_HCx4').supply.source\_fold\_t.min   # => 300.uS
$tester.ate\_hardware('VHDVS\_HCx8').supply.bandwidth.max       # => 255
$tester.ate\_hardware('VHDVS+').supply.irange.size             # => 6
$tester.ate\_hardware('VHDVS\_HC+').supply.sink\_fold\_t.max      # => 2
$tester.ate\_hardware('VHDVS+x2').supply.meter\_vrange          # => 18
$tester.ate\_hardware('VHDVS\_HC+x2').supply.forcev.min         # => -2
$tester.ate\_hardware('VHDVS\_HC+x4').supply.source\_fold\_t.min  # => 300.uS
$tester.ate\_hardware('VHDVS\_HC+x8').supply.bandwidth.max      # => 255

# Pin objects are connected up to their underlying tester resource
$dut.pins(:pin1).ate\_hardware.instrument                          # => 'HSD-U'
$dut.pins(:pin1).ate\_hardware.ppmu.forcei.max                     # => 0.05
$dut.pins(:k1).instrument\_type.instrument                         # => 'SupportBoard'
$dut.power\_pin\_groups(:avdd).ate\_hardware.instrument              # => 'VHDVS\_HC+x2'
$dut.power\_pin\_groups(:avdd).ate\_hardware.supply.forcev.cover?(4) # => true
~~~

<a class="anchor release_tag" name="v0_5_6"></a>
<h1><a href="#v0_5_6">Tag: v0.5.6</a></h1>

##### Branch: 'master'

##### by Stephen McGinty on 03-Feb-2016 09:30AM


Added initial support for Teradyne hardware configuration modelling (Scott Chen):

* Added import\_tester\_config, get\_tester\_instrument, get\_instrument\_slots, import\_chanmap,
  and get\_tester\_channel methods
* import\_tester\_config imports a standard IG-XL generated CurrentConfig.txt so Origen application can
  access the instrument/slot information for test generation. get\_tester\_instrument and
  get\_instrument\_slots are associated methods to quickly get slot/instrument information.
* import\_chanmap imports a standard IG-XL Channelmap
* get\_tester\_channel is an associated method to quickly get tester channel information.

Fixed bug causing some vectors marked as 'dont\_compress' to be compressed anyway.

<a class="anchor release_tag" name="v0_5_5"></a>
<h1><a href="#v0_5_5">Tag: v0.5.5</a></h1>

##### Branch: 'master'

##### by Daniel Hadad on 12-Nov-2015 17:56PM

Updated API support setting of diff-friendly output mode.
Mainly for regression testing support.

Can be set via :
~~~ruby
  $tester.diff_friendly_output = true
~~~

Currently sets test number output to 0 for IG-XL program generation only.

<a class="anchor release_tag" name="v0_5_4"></a>
<h1><a href="#v0_5_4">Tag: v0.5.4</a></h1>

##### Branch: 'master'

##### by Stephen McGinty on 30-Sep-2015 09:32AM


Bug fix to IG-Xl custom test instance API. If a finalize method is defined it will now
be called on all instances.

<a class="anchor release_tag" name="v0_5_3"></a>
<h1><a href="#v0_5_3">Tag: v0.5.3</a></h1>

##### Branch: 'master'

##### by Stephen McGinty on 29-Sep-2015 14:48PM


Added initial API to define custom test instance libraries for IG-XL based testers:

~~~ruby
# app\_interface.rb

def initialize(options = {})
  add\_custom\_til
end

# Example of how to use the custom library
def custom(name, options = {}) 
  ti = test\_instances.mylib.test\_a
  ti.my\_arg0 = 'my\_val'
  ti.my\_arg2\_alias = 'curr'
  ti.set\_my\_arg4('arg4\_val\_from\_method') 
end

# Add a custom test instance library
def add\_custom\_til
  add\_til :mylib,
          test\_a: {
            # Basic arg
            my\_arg0: :arg0,
            # Basic arg with default value
            my\_arg1: [:arg1, 'a\_default\_value'],
            # Basic arg with default value and predefined set of possible values, Origen will raise  an error
            # if it is ever set to a value not in the list
            my\_arg2: [:arg2, 'volt', %w(volt curr)],
            my\_arg3: :arg3,
            my\_arg4: :arg4,
            # Attribute aliases can be defined like this:
            aliases: {
              my\_arg\_alias:  :my\_arg,
              my\_arg1\_alias: :my\_arg1,
              my\_arg2\_alias: :my\_arg2
            },
            # Define any methods you want the test instance to have
            methods: {
              # An optional finalize function can be supplied to do any final test instance configuration, this
              # function will be called immediately before the test instance is finally rendered. The test instance
              # object itself will be passed in as an argument.
              finalize:    lambda  do |ti|
                ti.my\_arg3 = 'arg3\_set\_from\_finalize'
              end,
              # Example of a custom method.
              # In all cases the test method object will be passed in as the first argument.
              set\_my\_arg4: lambda  do |ti, val|
                ti.my\_arg4 = val
              end
            }
          },

          test\_b: {
            # ...
          }
end
~~~

<a class="anchor release_tag" name="v0_5_2"></a>
<h1><a href="#v0_5_2">Tag: v0.5.2</a></h1>

##### Branch: 'master'

##### by Stephen McGinty on 09-Sep-2015 05:07AM


Patch to make J750 multi-block match loops exit if any of the blocks passes. If multiple
conditions should be ANDed together then the user should defined them within the same
block.

<a class="anchor release_tag" name="v0_5_1"></a>
<h1><a href="#v0_5_1">Tag: v0.5.1</a></h1>

##### Branch: 'master'

##### by Stephen McGinty on 02-Sep-2015 11:43AM


Various V93K updates, this version produces patterns and test program that have been
verified to work on the tester

Added in the Ultraflex DSSC DigSrc and DigCap capabilities (Jiang Liu). 

All possible settings were added according to Ultraflex spec. To use these new features,
users must define the pins to be used with DigSrc and DigCap in the $dut/$soc file, similar
to how the DCVS instrument pins are defined today.

Then the ultraflex target file should call $tester.assign\_digsrc\_pins, $tester.assign\_digcap\_pins,
$tester.apply\_digsrc\_settings and $tester.apply\_digcap\_settings methods. The patterns will
then contain the appropriate instrument statements for digsrc and digcap including all the
settings. For overlay, the user would create a subroutine pattern which contains the necessary
microcodes for digsrc overlay, the user can use $tester.digsrc\_start, $tester.digsrc\_stop and
$tester.digsrc\_send methods as the basic building blocks for building the digsrc overlay subroutine.

Please refer to the digsrc\_overlay method in origen\_testers/test/dut.rb for an example of
constructing an digsrc overlay subroutine. Digcap only supports capture with stv right now,
this is currently the main way of using it. Added two new test cases in the subroutines.rb for
self-testing these newly added features.

<a class="anchor release_tag" name="v0_5_0"></a>
<h1><a href="#v0_5_0">Tag: v0.5.0</a></h1>

##### Branch: 'master'

##### by Stephen McGinty on 01-Sep-2015 09:23AM


This plugin now contains the only official tester models, those from Origen core are being
removed:

* Moved Doc and CommandBasedTester modules into this plugin (from Origen core)
* Removed all references to Origen::Testers
* Fixed issue with pattern generation crashing if a device is defined with no pins
* Aligned J750 match loop output to align with Origen core J750 output - basically added a
  clr\_fail if the loop exists successfully


<a class="anchor release_tag" name="v0_4_1"></a>
<h1><a href="#v0_4_1">Tag: v0.4.1</a></h1>

##### Branch: 'master'

##### by Stephen McGinty on 31-Aug-2015 08:59AM


Fix for V93K program generator regression on Ruby 2.2.2

<a class="anchor release_tag" name="v0_4_0"></a>
<h1><a href="#v0_4_0">Tag: v0.4.0</a></h1>

##### Branch: 'master'

##### by Stephen McGinty on 31-Aug-2015 05:06AM


Initial Origen-based release

<a class="anchor release_tag" name="v0_3_0_pre43"></a>
<h2><a href="#v0_3_0_pre43">Tag: v0.3.0.pre43</a></h2>

##### Branch: 'Trunk'

##### by Stephen McGinty on 17-Jul-2015 09:00AM


V93K updates after first round of on-tester debug:

* Repeats <= 16 are expanded to to match what the tester does by default, thereby keeping in-pattern
  vector numbers in sync with those from the tester's pattern display. A new attribute min\_repeat\_loop
  has been added to all testers to control this.
* Re-engineering of the generated match loop code. This version proven to work on the tester. The
  two pin match version has not been tried yet.
* Pattern file extensions added to pattern master files.
* A top-level pattern master file is now output called complete.pmfl which contains the patterns required
  for all flows.
* A pattern compiler control file (.aiv) is now also generated for all patterns required by a program
  generation run.

<a class="anchor release_tag" name="v0_3_0_pre42"></a>
<h2><a href="#v0_3_0_pre42">Tag: v0.3.0.pre42</a></h2>

##### Branch: 'Trunk'

##### by Stephen McGinty on 10-Jul-2015 13:34PM


Added ability for vector levelling to maintain the same number of clock pulses when the clk
transition is controlled from timing:
http://rgen.freescale.net/testers/latest/api/Testers/Timing.html#timing\_toggled\_pins-instance\_method

Added vertical pin identification comments to Teradyne patterns.

Added the ability to include vector and cycle counts in the pattern comments. Either supply
"-v" to the generate command or set $tester.vector\_comments in the environment/target to
enable it.
It is off by default since while the RGen differ will ignore them, tkdiff/winmerge will not
and it will make differences harder to view.

<a class="anchor release_tag" name="v0_3_0_pre41"></a>
<h2><a href="#v0_3_0_pre41">Tag: v0.3.0.pre41</a></h2>

##### Branch: 'Trunk'

##### by Ronald Lajaunie on 25-Jun-2015 12:16PM


Added Midband state to vectoring (for comparing only).

~~~ruby
  $dut.pins(:tdo).assert\_midband
  RGen.tester.cycle
  $dut.pins(:tdo).dont\_care
  RGen.tester.cycle
  $dut.pins(:tdo).assert\_midband!
  $dut.pins(:tdo).dont\_care
  RGen.tester.cycle

  $dut.port(:test\_port).assert\_midband
~~~

<a class="anchor release_tag" name="v0_3_0_pre40"></a>
<h2><a href="#v0_3_0_pre40">Tag: v0.3.0.pre40</a></h2>

##### Branch: 'Trunk'

##### by Stephen McGinty on 27-May-2015 09:44AM


Added a new shared command, testers:build, which provides ASCIIUtils-like test program build/integration
functionality.
So far only the V93K is supported but other platforms may be added in future.

The V93K implementation will currently merge flow and pattern master files which are the two files
that are generated by this plugin. Additional files could be added in future.

The user must supply a manifest file which describes the flows to be built and the sub-programs
from which they are comprised. The attributes of this file will be platform-dependent, here is
an example for V93K:

~~~yaml
flows:
  probe1:
    - continuity
    - scan
    - nvm
  probe2:
    - continuity
    - scan
    - functional

sub\_programs:  
  - name:           continuity
    # Paths can be relative to your RGen application root
    flow:           output/v93k/testflow/continuity.flow

  - name:           scan
    # Or relative to this file
    flow:           ../../output/v93k/testflow/scan.flow
    pattern\_master: ../../output/v93k/vectors/scan.pmfl

  - name:           nvm
    # Or absolute
    flow:           /proj/deviceX/test\_program/v93k/testflow/nvm.flow
    pattern\_master: /proj/deviceX/test\_program/v93k/testflow/nvm.pmfl

  - name:           functional
    flow:           /proj/deviceX/test\_program/v93k/testflow/functional.flow
    pattern\_master: /proj/deviceX/test\_program/v93k/testflow/functional.pmfl
~~~

A template manifest file can be built by running:

~~~text
rgen testers:build my\_manifest --new
~~~

<a class="anchor release_tag" name="v0_3_0_pre39"></a>
<h2><a href="#v0_3_0_pre39">Tag: v0.3.0.pre39</a></h2>

##### Branch: 'Trunk'

##### by Stephen McGinty on 22-May-2015 10:12AM


* More test cases and improvements to V93K generator, mainly in the area of nested flow control
  directives.
* Added support for limits (V93K):

~~~ruby
test\_method = test\_methods.j750\_tml.general\_dc
test\_method.lo\_limit = 100.uA
test\_method.hi\_limit = 150.uA
~~~

* Added ability to define methods when defining a custom V93K test method from an application,
  via an optional methods hash. The finalize method added recently is still supported but it
  should now be placed within the methods hash per the example below:

~~~ruby
module MyApp
  class Interface
    include Testers::ProgramGenerators

    def initialize(options={})
      add\_j750\_tml if tester.v93k?
    end

    # Define the test methods for the J750 test method library for the V93K
    def add\_j750\_tml
      add\_tml :j750\_tml,
        class\_name:      'J750Conversion',
        general\_dc: {
          class\_name:   'DigitalTest.GeneralDC',
          # Parameters can be defined with an underscored symbol as the name, this can be used
          # if the C++ implementation follows the standard V93K convention of calling the attribute
          # the camel cased version, starting with a lower-cased letter, i.e. 'testerState' in this
          # first example.
          # The attribute definition has two required parameters, the type and the default value.
          # The type can be :string, :current, :voltage, :time, :frequency, or :integer 
          # An optional 3rd parameter can be supplied to give an array of allowed values. If supplied,
          # RGen will raise an error upon an attempt to set it to an unlisted value.
          tester\_state: [:string, 'CONNECTED', %w(CONNECTED UNCHANGED)],
          test\_name: [:string, 'Functional'],
          # Parameters for PPMU
          'UsePPMU' => [:string, 'YES', %w(YES NO)],
          'UsePPMU.pinlist' => [:string, ''],
          'UsePPMU.forceMode' => [:string, 'VOLT', %w(VOLT CURR)],
          'UsePPMU.forceValue1' => ['UsePPMU.forceMode', 3800.mV],
          'UsePPMU.forceValue2' => ['UsePPMU.forceMode', 0],
          'UsePPMU.measureMode' => [:string, 'PAR', %w(PAR SER)],
          'UsePPMU.samples' => [:integer, 1],
          'UsePPMU.precharge' => [:string, 'OFF', %w(OFF ON)],
          'UsePPMU.prechargeVoltage' => [:voltage, 0],
          'UsePPMU.relaySwitchMode' => [:string, 'PARALLEL', ['BBM', 'MBB', 'PARALLEL(default)', 'PARALLEL']],
          'UsePPMU.settlingTime' => [:time, 0],
          'UsePPMU.termination' => [:string, 'OFF', %w(ON OFF)],
          'UsePPMU.testName1' => [:string, ''],
          'UsePPMU.testName2' => [:string, ''],
          # In cases where the C++ library has deviated from standard attribute naming conventions
          # (camel-cased with lower cased first character), the absolute attribute name can be given
          # as a string.
          # The Ruby/RGen accessor for these will be the underscored version, with '.' characters
          # converted to underscores, e.g. tm.use\_interpose, tm.use\_interpose\_start\_of\_body\_f, etc.
          'UseInterpose' => [:string, 'NO', %w(NO YES)],
          'UseInterpose.StartOfBodyF' => [:string, ''],
          'UseInterpose.StartOfBodyFInput' => [:string, ''],
          'UseInterpose.EndOfBodyF' => [:string, ''],
          'UseInterpose.EndOfBodyFInput' => [:string, ''],
          # Attribute aliases can be defined like this:
          aliases: {
            start\_of\_body\_f: 'UseInterpose.StartOfBodyF',
            start\_of\_body\_f\_args: 'UseInterpose.StartOfBodyFInput',
            end\_of\_body\_f: 'UseInterpose.EndOfBodyF',
            end\_of\_body\_f\_args: 'UseInterpose.EndOfBodyFInput',
          },
          # Define any methods you want the test method to have
          methods: {
            # An optional finalize function can be supplied to do any final test method configuration, this
            # function will be called immediately before the test method is finally rendered. The test method
            # object itself will be passed in as an argument.
            # In this example it is being used to automatically set the UseInterpose flag if any interpose
            # function arguments have been set.
            finalize: -> (tm) {
              if [:start\_of\_body\_f, :start\_of\_body\_f\_args, :end\_of\_body\_f, :end\_of\_body\_f\_args].any? do |arg| 
                  tm.send(arg) && !tm.send(arg).empty?
                end
                tm.use\_interpose = "YES" 
              end
            },
            # Example of a custom method, here to emulate functionality available to Teradyne test instance objects.
            # In all cases the test method object will be passed in as the first argument.
            set\_measure\_mode: -> (tm, mode) {
              if mode == :current || mode == :fvmi
                tm.use\_ppmu\_force\_mode = "VOLT"
              elsif mode == :voltage || mode == :fimv
                tm.use\_ppmu\_force\_mode = "CURR"
              end
            },
          }
        },
        
        general\_digital: {
          # Define another test method within this library... 

        }
    end
end
~~~

<a class="anchor release_tag" name="v0_3_0_pre38"></a>
<h2><a href="#v0_3_0_pre38">Tag: v0.3.0.pre38</a></h2>

##### Branch: 'Trunk'

##### by Stephen McGinty on 19-May-2015 09:01AM


* Fixed issue with multi-mode not padding to complete a partial vector group at the end
  of the pattern.
* Various improvements and additional test cases added to the V93K flow control API.
* Made V93K test\_suites delegate method calls to their test\_method, this means that a test\_suite
  + test\_method combo can be used as a drop in replacement for a Teradyne test\_instance object
  within a multi-platform interface:

~~~ruby
if tester.j750?
  i = test\_instances.functional(name, options)
elsif tester.v93k?
  i = test\_suites.add(name, options)
  i.test\_method = test\_methods.j750\_tml.general\_digital
end
# Now you can treat these the same for many attributes. For example on V93K the pattern is
# a test suite attribute whereas the interpose functions are provided by the (custom) test
# method, however these can now be treated as if they are a single entity:
i.pattern = name
i.start\_of\_body\_f = "TfsC90InterposeFunc"
i.start\_of\_body\_f\_args = "PGM\_CAL\_PARAS,cal\_paras"
~~~

* Added an API to allow applications to define custom V93K test methods:

~~~ruby
module MyApp
  class Interface
    include Testers::ProgramGenerators

    def initialize(options={})
      add\_j750\_tml if tester.v93k?
    end

    # Define the test methods for the J750 test method library for the V93K
    def add\_j750\_tml
      # Add a new test method library, this will be available as test\_methods.j750\_tml.
      # This method can be called multiple times to define multiple custom libraries.
      add\_tml :j750\_tml,
        # Optionally supply a class name attribute that will be prefixed to all test method
        # classes (meaning the C++ class name) defined herein
        class\_name:      'J750Conversion',
        # Defines a test method called general\_digital, a new instance of this can be created
        # by test\_methods.j750\_tml.general\_digital
        general\_digital: {
          # The full C++ class name will be 'J750Conversion.DigitalTest.GeneralDigital', this
          # is optional and by default will be the camel-cased version of the method name, e.g.
          # 'GeneralDigital' in this case.
          class\_name:   'DigitalTest.GeneralDigital',
          # Parameters can be defined with an underscored symbol as the name, this can be used
          # if the C++ implementation follows the standard V93K convention of calling the attribute
          # the camel cased version, starting with a lower-cased letter, i.e. 'testerState' in this
          # first example.
          # The attribute definition has two required parameters, the type and the default value.
          # The type can be :string, :current, :voltage, :time, :frequency, or :integer 
          # An optional 3rd parameter can be supplied to give an array of allowed values. If supplied,
          # RGen will raise an error upon an attempt to set it to an unlisted value.
          tester\_state: [:string, 'CONNECTED', %w(CONNECTED UNCHANGED)],
          test\_name: [:string, 'Functional'],
          # In cases where the C++ library has deviated from standard attribute naming conventions
          # (camel-cased with lower cased first character), the absolute attribute name can be given
          # as a string.
          # The Ruby/RGen accessor for these will be the underscored version, with '.' characters
          # converted to underscores, e.g. tm.use\_interpose, tm.use\_interpose\_start\_of\_body\_f, etc.
          'UseInterpose' => [:string, 'NO', %w(NO YES)],
          'UseInterpose.StartOfBodyF' => [:string, ''],
          'UseInterpose.StartOfBodyFInput' => [:string, ''],
          'UseInterpose.EndOfBodyF' => [:string, ''],
          'UseInterpose.EndOfBodyFInput' => [:string, ''],
          # Attribute aliases can be defined like this:
          aliases: {
            start\_of\_body\_f: 'UseInterpose.StartOfBodyF',
            start\_of\_body\_f\_args: 'UseInterpose.StartOfBodyFInput',
            end\_of\_body\_f: 'UseInterpose.EndOfBodyF',
            end\_of\_body\_f\_args: 'UseInterpose.EndOfBodyFInput',
          },
          # An optional finalize function can be supplied to do any final test method configuration, this
          # function will be called immediately before the test method is finally rendered. The test method
          # object itself will be passed in as an argument.
          # In this example it is being used to automatically set the UseInterpose flag if any interpose
          # function arguments have been set.
          finalize: -> (tm) {
            if [:start\_of\_body\_f, :start\_of\_body\_f\_args, :end\_of\_body\_f, :end\_of\_body\_f\_args].any? do |arg| 
                tm.send(arg) && !tm.send(arg).empty?
              end
              tm.use\_interpose = "YES" 
            end
          }
        },
        
        general\_dc: {
          # Define another test method within this library... 

        }
    end
end
~~~

<a class="anchor release_tag" name="v0_3_0_pre37"></a>
<h2><a href="#v0_3_0_pre37">Tag: v0.3.0.pre37</a></h2>

##### Branch: 'Trunk'

##### by Stephen McGinty on 04-May-2015 10:37AM


Added fixes (and tests) for the following two bugs:

* Fixed non-optimal compression in single mode:

~~~text
OLD:

// Wait for 2.4ms
repeat     60000     nvmbist     0 1 0 1 0 X X X 
repeat               nvmbist     0 1 0 1 0 X X X 

NEW:

// Wait for 2.4ms
repeat     60001     nvmbist     0 1 0 1 0 X X X 
~~~

* Fixed duplicate repeat issue at end of pattern in dual mode:

~~~text
OLD:

// Wait for 12.0us
                                    > lynx                         1 
repeat 600                          > lynx                         1 
// COMMENT: End Test
repeat 600                          > lynx                         1 
                                    > lynx                         1 
}                                                                                               

NEW:

// Wait for 12.0us
                                    > lynx                         1 
repeat 600                          > lynx                         1 
// COMMENT: End Test
                                    > lynx                         1 
                                    > lynx                         1 
}                                                                                               
~~~

<a class="anchor release_tag" name="v0_3_0_pre36"></a>
<h2><a href="#v0_3_0_pre36">Tag: v0.3.0.pre36</a></h2>

##### Branch: 'Trunk'

##### by Daniel Hadad on 27-Apr-2015 16:03PM



Corrected minor bug that only occurred when tester wait called for time greater than
maximum repeat count possible on tester.  Extraneous vector was being generated after each
max repeat count vector.

<a class="anchor release_tag" name="v0_3_0_pre35"></a>
<h2><a href="#v0_3_0_pre35">Tag: v0.3.0.pre35</a></h2>

##### Branch: 'Trunk'

##### by Stephen McGinty on 23-Apr-2015 03:07AM


Added fix (and test) for setting resources\_filename during interface initialize.

This update also ensures that the given platform generator module is loaded before initialize
is called where an interface includes Testers::ProgramGenerators.

<a class="anchor release_tag" name="v0_3_0_pre34"></a>
<h2><a href="#v0_3_0_pre34">Tag: v0.3.0.pre34</a></h2>

##### Branch: 'Trunk'

##### by Stephen McGinty on 21-Apr-2015 08:31AM


Changed internal implementation of TestInstance#set\_wait\_flags method to remove the need
for a tester instance method

<a class="anchor release_tag" name="v0_3_0_pre33"></a>
<h2><a href="#v0_3_0_pre33">Tag: v0.3.0.pre33</a></h2>

##### Branch: 'Trunk'

##### by Stephen McGinty on 17-Apr-2015 09:12AM


Initial release of the V93K test program generator and general feature improvements to support
the creation of test programs for multiple platforms.

**V93K**

The V93K generator now has a similar level of functionality to the supported Teradyne platforms,
here is an example of how to use it:

~~~ruby
# Generate a functional test
def functional(name, options = {})
  test\_suite = test\_suites.run(name, options)
  test\_method = test\_methods.ac\_tml.ac\_test.functional\_test
  test\_suite.test\_method = test\_method
  test\_suite.pattern = name
  flow.test(test\_suite, options)
end
~~~

The output is a complete flow file containing all test method and test suite definitions (equivalent
to Teradyne test instances + patsets) and a pattern master file listing all patterns required by
the given flow.

Notable things still todo:

* The output has not been tried live yet. Although it is definitely generating valid V93K syntax
  there could be typo-like bugs.
* The flow control API is implemented with the exception of the if\_any and if\_all passed/failed
  options. V93K does not provide native support for these and discussion is ongoing about whether
  to deprecate these from the flow control API or possibly to implement on V93K via a C++ shim.
* All SmarTest built-in DC test methods have been implemented, however only a subset of the AC
  tests have been implemented so far. This is just a tedious and manual job and will be done in
  due course.
* How to handle custom test methods has still to be defined and will be worked out in the course
  of creating the first application to use this generator (C90TFS NVM).

**NEW MULTI-PLATFORM FEATURES**

The following features have been added to the Testers plugin to better support multi-platform test
program generation (i.e. to make it easier to implement an app that supports multiple platforms),
and also to make the program generator work better in a BOM-style application.

Previously, test program interfaces were automagically selected based on the current tester type,
however that won't work in a BOM app setup where potentially many sub-modules each implement
their own interface (or they could share one) and it is impossible to know which one to pick.
To solve this, top-level flows (i.e. not required for sub-flows which will inherit the interface
from their parent) should now define the class of the interface that they want to use:

~~~ruby
Flow.create interface: 'C90TFSNVMTester::Interface' do

end
~~~

For now this is optional and the old-style lookup is still supported, but that will eventually be
deprecated and supplying an interface option will be a hard required.

Note that the above interface example does not specify a test platform, this is because it is now
possible to create a universal interface.
Instead of including platform-specific generators, an app's interface class can now include just
a universal generator module:

~~~ruby
module C90TFSNVMTester
  class Interface
    include Testers::ProgramGenerators
  end
end
~~~

The interface instance will be automatically endowed with the methods to support the test platform
being used at runtime. The bottom line is that an interface to support the J750 would otherwise
be identical to how it used to be:

~~~ruby
module C90TFSNVMTester
  class Interface
    include Testers::ProgramGenerators

    def functional(name, options = {})
      ins = test\_instances.functional(name, options)
      pname = "#{name}\_pset"
      pset = patsets.add(pname, [{ pattern: "#{name}.PAT" }])
      ins.pattern = pname
      line = flow.test(ins, options)
    end
  end
end
~~~

Note that this means that the above interface would now also support UltraFLEX as well if it was run
with the appropriate target.

It is now much easier to add support for additional test platforms rather than having separate
interfaces and trying to juggle shared code between them. To add V93K support to the above interface
you would do:

~~~ruby
module C90TFSNVMTester
  class Interface
    include Testers::ProgramGenerators

    def functional(name, options = {})
      if tester.j750? || tester.ultraflex?
        ins = test\_instances.functional(name, options)
        pname = "#{name}\_pset"
        pset = patsets.add(pname, [{ pattern: "#{name}.PAT" }])
        ins.pattern = pname
        line = flow.test(ins, options)
      elsif tester.v93k?
        test\_suite = test\_suites.run(name, options)
        test\_method = test\_methods.ac\_tml.ac\_test.functional\_test
        test\_suite.test\_method = test\_method
        test\_suite.pattern = name
        flow.test(test\_suite, options)
      end
    end
  end
end
~~~

This now opens the door to the creation of multi-platform test setup libraries (which was always
the intention of the architecture design of the RGen program generator) and the Testers plugin
will provide a basic library to make it easier to get started when dealing with basic tests 
(e.g. functional, current\_measure, voltage\_measure, etc.).
It is of course envisaged that more complex domain-specific libraries will start to emerge within
the community.

Initially the Tester plugin's basic library is a proof of concept and provides a functional test
setup which will work on all platforms (though it has not yet been tested on any).

To use it create a very simple interface in your app:

~~~ruby
module C90TFSNVMTester
  class Interface
    include Testers::BasicTestSetups
  end
end
~~~

In your flow you can now generate functional tests for any platform:

~~~ruby
Flow.create interface: 'C90TFSNVMTester::Interface' do
  functional :erase,   sbin: 100
  functional :rd\_all1, sbin: 110
end
~~~

It is possible to apply defaults (e.g. set bin 3 for all), or to tweak the output (e.g. add an
interpose function call on Teradyne platforms) from the interface.
See the API for details on how to do that:
[BasicTestSetups](http://rgen.freescale.net/testers/latest/api/Testers/BasicTestSetups.html)

<a class="anchor release_tag" name="v0_3_0_pre32"></a>
<h2><a href="#v0_3_0_pre32">Tag: v0.3.0.pre32</a></h2>

##### Branch: 'Trunk'

##### by Daniel Hadad on 08-Apr-2015 18:37PM


Corrected bug in J750 match loop with multiple entries-- extra set\_code being called.

<a class="anchor release_tag" name="v0_3_0_pre31"></a>
<h2><a href="#v0_3_0_pre31">Tag: v0.3.0.pre31</a></h2>

##### Branch: 'Trunk'

##### by Stephen McGinty on 02-Apr-2015 05:08AM


Fix for issue when requiring into a 3rd party app (introduced in pre29)

<a class="anchor release_tag" name="v0_3_0_pre30"></a>
<h2><a href="#v0_3_0_pre30">Tag: v0.3.0.pre30</a></h2>

##### Branch: 'Trunk'

##### by Stephen McGinty on 31-Mar-2015 04:01AM


Updated the V93K generator class structure to match the conventions recently established
for
the IG-XL-based testers.

Added V93K interface and added the V93K program generator to the regression list (though
it
doesn't currently generate any output).

Now ready to start adding functionality...

<a class="anchor release_tag" name="v0_3_0_pre29"></a>
<h2><a href="#v0_3_0_pre29">Tag: v0.3.0.pre29</a></h2>

##### Branch: 'Trunk'

##### by Stephen McGinty on 30-Mar-2015 05:58AM


Fairly major internal refactor to support running multiple program generation runs back to back,
this is necessary amongst other things to support testing the program generators.
Regression tests have now been enabled for the J750, UltraFLEX and J750\_HPT program generators.

This update restores the internal generator architecture to have a separate class structure for
each supported platform, rather than customizing a single class at runtime.
Unfortunately some fairly minor breaking changes will be apparent at application-level as a result
of this change:

* The interface definition is now the same as RGen core and no self.platform method is required,
  to create an interface just include the appropriate generator module:

~~~ruby
class MyJ750Interface
  include Testers::J750::Generator
end
~~~

* The J750\_HPT now requires a dedicated interface to be setup for it, see the example in
  lib/testers/test/ for how to do this while sharing the bulk of the code with a J750 interface.

The patgroup generators are currently untested and could therefore be broken by this update, though
it is unlikely.

<a class="anchor release_tag" name="v0_3_0_pre28"></a>
<h2><a href="#v0_3_0_pre28">Tag: v0.3.0.pre28</a></h2>

##### Branch: 'Trunk'

##### by Stephen McGinty on 19-Mar-2015 10:12AM


Added vector levelling.

When enabled, all vectors will be converted to use the timeset with the smallest period that is
encountered in the pattern. An error will be raised if a vector is encountered who's period is not
a multiple of the smallest period.

This feature is enabled for the V93K tester by default and disabled for Teradyne testers since there
is no time penalty from modulating the period by switching timeset/timeplate on that platform.

<a class="anchor release_tag" name="v0_3_0_pre27"></a>
<h2><a href="#v0_3_0_pre27">Tag: v0.3.0.pre27</a></h2>

##### Branch: 'Trunk'

##### by Stephen McGinty on 18-Mar-2015 12:36PM


Removed the original vector compression logic and made everything, including single mode
patterns, now use the vector pipeline. This is to allow it to be used to create a period-levelling
system which will be required for the V93K.

Added $tester.align and $tester.align\_to\_last methods to align the next vector to the start
or end of a multi-vector frame. See the pattern\_footer method in the IGXL-based tester class
for an example where it is used to ensure that the end\_module microcode falls on the last
vector of a frame. Generally the tester classes will be responsible now for using these methods
as required to ensure that their microcode will align properly in multi vector modes.

Added a multi-mode vector test to the regression list. The J750 output matches that from RGen core,
not sure if the output on other platforms is valid yet - especially may not be right for UFlex
case where vector padding kicks in on short patterns.
This multi-mode pattern should be expanded in future as tester API methods become multi-mode
aware.

Added more test coverage for V93K.

<a class="anchor release_tag" name="v0_3_0_pre26"></a>
<h2><a href="#v0_3_0_pre26">Tag: v0.3.0.pre26</a></h2>

##### Branch: 'Trunk'

##### by Stephen McGinty on 13-Mar-2015 06:43AM


Added V93K generators from RGen core, without modification other than that required to
make them run within the Testers plugin.

Added legacy test of V93K pattern generation compatibility to allow it to be safely
deprecated from RGen core.

Enabled standard auto-linting.

Did some minor refactoring of existing code.

<a class="anchor release_tag" name="v0_3_0_pre25"></a>
<h2><a href="#v0_3_0_pre25">Tag: v0.3.0.pre25</a></h2>

##### Branch: 'Trunk'

##### by Daniel Hadad on 02-Feb-2015 16:15PM


Wrapped standalone-dependent configs so that they aren't run by app calling Testers gem.

<a class="anchor release_tag" name="v0_3_0_pre24"></a>
<h2><a href="#v0_3_0_pre24">Tag: v0.3.0.pre24</a></h2>

##### Branch: 'Trunk'

##### by Daniel Hadad on 06-Jan-2015 14:17PM


Converted to gem.

<a class="anchor release_tag" name="v0_2_0_dev23"></a>
<h2><a href="#v0_2_0_dev23">Tag: v0.2.0.dev23</a></h2>

##### Branch: 'Trunk'

##### by Daniel Hadad on 12-Dec-2014 17:45PM


Added MTO instrument statement back for all UltraFLEX patterns but controlled via target.
So by default will not be included for all patterns but user can add it if desired.

<a class="anchor release_tag" name="v0_2_0_dev22"></a>
<h2><a href="#v0_2_0_dev22">Tag: v0.2.0.dev22</a></h2>

##### Branch: 'Trunk'

##### by Aaron J Burgmeier on 06-Dec-2014 16:17PM


updated pattern generation for multi-mode vector support - correct repeat counts are now
being properly applied
on the correct vectors. Vector padding is also being applied to fill out a complete vector
group.
Also vector repeats are also being split in order to preserve vector comments in their
original position.
Pattern header content has been adjusted to reflect the correct UltraFlex mode (single,
dual, quad).

NOTE: An instrument statement for 'mto' was being erroneously included in all pattern
headers.  This has been
changed such that it will only be included if the :memory\_test option is set to true for
the pattern header
(this is the same solution used in the igxl\_based\_tester class).  Be aware that this
caused 'rgen examples'
 to fail four patterns that expected the 'mto' instrument to be declared.  I have updated
these patterns
with the new pattern generation behavior (e.g. without the mto instrument).

<a class="anchor release_tag" name="v0_2_0_dev21"></a>
<h2><a href="#v0_2_0_dev21">Tag: v0.2.0.dev21</a></h2>

##### Branch: 'Trunk'

##### by Daniel Hadad on 21-Nov-2014 22:58PM



#### Changes in this release

- Modifed to rely less on Tester module in RGen core and more on additional
  files now placed in Testers plug-in. Confirmed to work with RGen core files
  temporarily removed (but not yet so as to permit deprecate warnings to
  users). This is to allow future modifications to be able to be done directly in Testers plug-in.
- Reverted back to $dut instance naming from $soc.
- Rgen examples for this plug-in using UltraFLEX target only instead of J750
  for program command--due to bug noted below were examples can't run multiple
  testers.  UltraFLEX currently in higher use for this plug-in.
- Minor fixes that were preventing UltraFLEX regression testing.

#### Known issues:

- Running multiple targets back to back for program generation across different testers giving issue.  Only impacts 'rgen examples' command but needs to be fixed soon.
- Does not support proper placement of stv on multi-cycle JTAG patterns (neither does RGen core Tester class) yet
- Added concept of Pattern subroutine sheets to code-- not yet fully supported.
  
#### Checkouts performed:

- rgen examples (now will always have to pass prior to release)

#### Features not yet supported:

- Program Parsing (there but needs test case)
- V93K support (almost there)
- UF MTO support (custom template used today, need to add to library)

#### NOTE: Debugger 'testers' not included in this app, please see 'Debuggers' plug-in.


<a class="anchor release_tag" name="v0_2_0_dev20"></a>
<h2><a href="#v0_2_0_dev20">Tag: v0.2.0.dev20</a></h2>

##### Branch: 'Trunk'

##### by Brian Caquelin on 17-Nov-2014 11:07AM


Fixed bug where compiler woulf crash if users had not previously created a .atp file.

All of these bugs I am finding are due to writing documentation on how the compiler
SHOULD work and it is clear that good, prompt documentation will improve our code base or
at least my contributions to it.

<a class="anchor release_tag" name="v0_2_0_dev19"></a>
<h2><a href="#v0_2_0_dev19">Tag: v0.2.0.dev19</a></h2>

##### Branch: 'Trunk'

##### by Brian Caquelin on 17-Nov-2014 10:11AM


Updated compiler to look for cmd line .atp patterns at RGen.root and below

<a class="anchor release_tag" name="v0_2_0_dev18"></a>
<h2><a href="#v0_2_0_dev18">Tag: v0.2.0.dev18</a></h2>

##### Branch: 'Trunk'

##### by Brian Caquelin on 14-Nov-2014 12:22PM


updated ultraflex compiler to version 1.5.3.3

<a class="anchor release_tag" name="v0_2_0_dev17"></a>
<h2><a href="#v0_2_0_dev17">Tag: v0.2.0.dev17</a></h2>

##### Branch: 'Trunk'

##### by Brian Caquelin on 10-Nov-2014 09:54AM


updated pattern compiler to handle callbacks natively instead of inside the user
application

<a class="anchor release_tag" name="v0_2_0_dev16"></a>
<h2><a href="#v0_2_0_dev16">Tag: v0.2.0.dev16</a></h2>

##### Branch: 'Trunk'

##### by Priyavadan Kumar on 10-Nov-2014 09:49AM


Updated the testers plugin to enable bitmapping support on the UltraFLEX using the MTO
instrument.

<a class="anchor release_tag" name="v0_2_0_dev15"></a>
<h2><a href="#v0_2_0_dev15">Tag: v0.2.0.dev15</a></h2>

##### Branch: 'Trunk'

##### by Brian Caquelin on 07-Nov-2014 11:45AM


updated pattern compiler to work with 'rgen g'

<a class="anchor release_tag" name="v0_2_0_dev14"></a>
<h2><a href="#v0_2_0_dev14">Tag: v0.2.0.dev14</a></h2>

##### Branch: 'Trunk'

##### by Brian Caquelin on 07-Nov-2014 08:28AM


Added in pattern compiler support for programmatic access.  This works as follows:

~~~ruby
module CompilerSpec
  class CompilerDUT
    include Testers::PatternCompilers
    include RGen::TopLevel

    attr\_accessor :pinmap
    attr\_reader   :ltg\_compiler\_options
    attr\_reader   :functional\_compiler\_options
    attr\_reader   :bist\_compiler\_options

    def initialize
      @ltg\_compiler\_options = {
        path: "#{RGen.root}/spec/patterns/atp/ltg",
        clean: false,
        location: :local,
        recursive: false,
        output\_directory: "#{RGen.root}/spec/patterns/bin",
        opcode\_mode: 'single',
        comments: true
      }

      @functional\_compiler\_options = {
        path: "#{RGen.root}/spec/patterns/atp/functional",
        clean: true,
        location: :local,
        recursive: false,
        output\_directory: "#{RGen.root}/spec/patterns/bin",
        opcode\_mode: 'single',
        comments: false
      }

      @bist\_compiler\_options = {
        clean: true,
        location: :local,
        recursive: false,
        output\_directory: "#{RGen.root}/spec/patterns/bin",
        pinmap\_workbook: "#{RGen.root}/spec/patterns/atp/bist/bist\_pins.txt",
        opcode\_mode: 'single',
        comments: false
      }
    end
  end

  describe "Ultraflex Pattern Compiler" do

    before :all do
      RGen.target.temporary = 'ultraflex\_compiler'
      RGen.app.load\_target!
      RGen.load\_application
      $dut = CompilerDUT.new
      $dut.pinmap = "#{RGen.root}/spec/patterns/compiler\_pins.txt"
      # Clean up any .PAT and .log files in our spec testing area
      Dir.glob("#{$dut.ltg\_compiler\_options[:output\_directory]}/**/*.PAT").each do |f|
        File.delete(f)
      end
      Dir.glob("#{$dut.functional\_compiler\_options[:output\_directory]}/**/*.PAT").each do
|f|
        File.delete(f)
      end
      Dir.glob("#{$dut.ltg\_compiler\_options[:path]}/**/*.log").each do |f|
        File.delete(f)
      end
      Dir.glob("#{$dut.functional\_compiler\_options[:path]}/**/*.log").each do |f|
        File.delete(f)
      end
    end

    it "creates pattern compiler instances correctly" do
      $dut.pattern\_compilers.should == {}
      $dut.add\_compiler(:ltg, :ultraflex, $dut.ltg\_compiler\_options)
      # pattern\_compiler method will show compiler instances
      # for whatever the current tester platform is enabled
      $dut.pattern\_compilers.keys.should == [:ltg]
      $dut.add\_compiler(:functional, :ultraflex, $dut.functional\_compiler\_options)
      $dut.pattern\_compilers.count.should == 2
    end

    it "finds the correct number of patterns" do
      $dut.pattern\_compilers[:ltg].find\_jobs
      ltg\_atp\_count = $dut.pattern\_compilers[:ltg].count
      ltg\_atp\_count.should == 1
    end

    it "can search the compiler job queue" do
      $dut.pattern\_compilers[:ltg].jobs(/fail/).should == false
      $dut.pattern\_compilers[:ltg].jobs(/idreg/).should == true
      $dut.pattern\_compilers[:ltg].jobs('ls2080').should == true
      $dut.pattern\_compilers[:ltg].jobs(0).should == true
      $dut.pattern\_compilers[:ltg].jobs($dut.pattern\_compilers[:ltg].count+1).should ==
false
    end

    it "can compile the expected number of patterns" do
      ltg\_atp\_count = $dut.pattern\_compilers[:ltg].count
      ltg\_atp\_count.should == 1
      ltg\_pat\_matches =
Dir.glob("#{$dut.ltg\_compiler\_options[:output\_directory]}/**/*.PAT").count
      ltg\_pat\_matches.should == 0
      $dut.pattern\_compilers[:ltg].run
      ltg\_pat\_matches =
Dir.glob("#{$dut.ltg\_compiler\_options[:output\_directory]}/**/*.PAT").count
      ltg\_atp\_count.should == ltg\_pat\_matches
    end

    it "can save log files" do
      ltg\_pat\_matches =
Dir.glob("#{$dut.ltg\_compiler\_options[:output\_directory]}/**/*.PAT").count
      if $dut.ltg\_compiler\_options[:clean] == false
        Dir.glob("#{$dut.ltg\_compiler\_options[:path]}/**/*.log").count.should ==
ltg\_pat\_matches
      else
        Dir.glob("#{$dut.ltg\_compiler\_options[:path]}/**/*.log").count.should == 0
      end
    end

    it "can find and compile patterns recursively/non-recursively in directories and
lists" do
      # Clean up patterns and log files from previous spec testing
      Dir.glob("#{$dut.ltg\_compiler\_options[:output\_directory]}/**/*.PAT").each do |f|
        File.delete(f)
      end
      Dir.glob("#{$dut.ltg\_compiler\_options[:path]}/**/*.log").each do |f|
        File.delete(f)
      end
      $dut.pattern\_compilers[:functional].find\_jobs
      functional\_atp\_count = $dut.pattern\_compilers[:functional].count
      functional\_atp\_count.should == 1
      functional\_pat\_matches =
Dir.glob("#{$dut.functional\_compiler\_options[:output\_directory]}/**/*.PAT").count
      functional\_pat\_matches.should == 0
      $dut.pattern\_compilers[:functional].run
      functional\_pat\_matches =
Dir.glob("#{$dut.functional\_compiler\_options[:output\_directory]}/**/*.PAT").count
      functional\_atp\_count.should == functional\_pat\_matches
      # Turn on the recursive flag which will find patterns and lists in sub-directories
      $dut.functional\_compiler\_options[:recursive] = true
      $dut.add\_compiler(:functional\_recursive, :ultraflex,
$dut.functional\_compiler\_options)
      $dut.pattern\_compilers[:functional\_recursive].find\_jobs
      functional\_atp\_count = $dut.pattern\_compilers[:functional\_recursive].count
      functional\_atp\_count.should == 7
      functional\_pat\_matches =
Dir.glob("#{$dut.functional\_compiler\_options[:output\_directory]}/**/*.PAT").count
      # Should have one pattern from previous run
      functional\_pat\_matches.should == 1
      $dut.pattern\_compilers[:functional\_recursive].run
      functional\_pat\_matches =
Dir.glob("#{$dut.functional\_compiler\_options[:output\_directory]}/**/*.PAT").count
      functional\_atp\_count.should == functional\_pat\_matches
    end

    it "can delete log files" do
      functional\_pat\_matches =
Dir.glob("#{$dut.functional\_compiler\_options[:output\_directory]}/**/*.PAT").count
      if $dut.functional\_compiler\_options[:clean] == false
        Dir.glob("#{$dut.functional\_compiler\_options[:path]}/**/*.log").count.should ==
functional\_pat\_matches
      else
        Dir.glob("#{$dut.functional\_compiler\_options[:path]}/**/*.log").count.should == 0
      end
    end

    it "allows users to pass files individually inside an enumeration" do
      # Clean up patterns and log files from previous spec testing
      Dir.glob("#{$dut.functional\_compiler\_options[:output\_directory]}/**/*.PAT").each do
|f|
        File.delete(f)
      end
      Dir.glob("#{$dut.functional\_compiler\_options[:path]}/**/*.log").each do |f|
        File.delete(f)
      end
      # This compiler instance does not specify path but does specify a pinmap
      # The pinmap passed as an option should override $dut.pinmap
      $dut.add\_compiler(:bist, :ultraflex, $dut.bist\_compiler\_options)
      # The pinmap passed to the compiler as an option overrode the one at $dut.pinmap
      $dut.pinmap.should\_not == $dut.pattern\_compilers[:bist].pinmap.to\_s
      bist\_pattern\_count = Dir["#{RGen.root}/spec/patterns/atp/bist/*.atp*"].count
      Dir["#{RGen.root}/spec/patterns/atp/bist/*.atp*"].each do |f|
        atp = Pathname.new(f)
        next unless atp.extname == '.gz' || atp.extname == '.atp'
        # Ignore patterns that do not have 'prod' in the name
        next unless atp.basename.to\_s.match(/prod/)
        $dut.pattern\_compilers[:bist].find\_jobs(atp)
      end
      # Filtered one pattern
      $dut.pattern\_compilers[:bist].count.should == 3
      # Save the compiler queue to a pattern list file for diff or run later
      $dut.pattern\_compilers[:bist].to\_list(name: 'bist\_compile', force: true,
output\_directory: $dut.bist\_compiler\_options[:output\_directory])
      $dut.pattern\_compilers[:bist].run
      bist\_pat\_matches =
Dir.glob("#{$dut.bist\_compiler\_options[:output\_directory]}/**/*.PAT").count
      bist\_pat\_matches.should == bist\_pattern\_count - 1
      # Clean up patterns and log files from previous spec testing
      Dir.glob("#{$dut.bist\_compiler\_options[:output\_directory]}/**/*.PAT").each do |f|
        File.delete(f)
      end
      $dut.pattern\_compilers[:bist].count.should == 0
    end

    it "can compile a pattern list" do
      # Compile the patterns using the pattern list created ea
      $dut.pattern\_compilers[:bist].run(list, $dut.bist\_compiler\_options)
      bist\_pat\_matches =
Dir.glob("#{$dut.bist\_compiler\_options[:output\_directory]}/**/*.PAT").count
      # compiled patterns count should match what we had when we wrote out the pattern
list
      bist\_pat\_matches.should == 3
    end
  end
end
~~~

Also added hooks to allow 'rgen g <pattern> --compile <compiler name>' to kick off
compiler but it is not tested yet.


<a class="anchor release_tag" name="v0_2_0_dev13"></a>
<h2><a href="#v0_2_0_dev13">Tag: v0.2.0.dev13</a></h2>

##### Branch: 'Trunk'

##### by Jiang Liu on 22-Oct-2014 17:54PM


- changed the import of instruments for J750 and Uflex to near the end of pattern header
to prevent pattern compilation error on uflex (where order matters).

<a class="anchor release_tag" name="v0_2_0_dev12"></a>
<h2><a href="#v0_2_0_dev12">Tag: v0.2.0.dev12</a></h2>

##### Branch: 'Trunk'

##### by Jiang Liu on 22-Oct-2014 10:47AM


- Added uflex capability of fetching and returning dut dc\_pins, which allows dc instrument
to be imported into pattern based on requirements.
- Uflex example patterns would now import the dc instrument in the pattern as a check of
this feature.

<a class="anchor release_tag" name="v0_2_0_dev11"></a>
<h2><a href="#v0_2_0_dev11">Tag: v0.2.0.dev11</a></h2>

##### Branch: 'Trunk'

##### by Brian Caquelin on 19-Oct-2014 08:00AM


Updated linux pattern compiler to work on cmd line AND offline so compile jobs can be done
and prepared on Windows or Linux.  Cmd line args changed slightly:

~~~ruby
opt\_parser = OptionParser.new do |opts|
  opts.banner = 'USAGE: rgen latpc [options] ; --pinmap is required.'
  opts.on('-f', '--path DIR|PATTERN|LIST', 'Pattern directory, individual pattern, or
pattern list to be compiled.  Required.') { |path| options[:path] = path }
  opts.on('-p', '--pinmap PINMAP', 'Path and filename for the pinmap to be used.
Required.') { |pinfile| options[:pinmap\_workbook] = pinfile }
  opts.on('-o', '--output DIRECTORY', 'Path to the directory to place compiled .PAT
files') { |dir| options[:output\_directory] = dir }
  opts.on('-c', '--clean', 'Deleted .log files after compilation') { |a| boptions[:clean]
= true }
  opts.on('-t', '--target TARGET', 'Temporarily changes target to TARGET for this
command') { |tar| options[:target] = tar }
  opts.on('-l', '--location LOCATION', "'local' or 'lsf', defaults to 'local'") { |locn|
options[:location] = locn }
  opts.on('-r', '--recursive', "Do a recursive directory search for patterns if the '-f'
arg is a directory") { |r| options[:recursive] = true }
  opts.on\_tail('-h', '--help', 'Show this message') { puts opts; exit }
end
~~~

When using the compiler offline (inside RGen) the following steps are required:

~~~ruby
bist\_options = {
  path: "#{RGen.root}/output/patterns/atp/fslbist",
  clean: true,          # controls whether compiler log files are deleted after
compilation
  target: nil,           # allows user to temporarily set target and run compilation
  location: 'local',     # controls whether the commands go to the LSF or run locally
  recursive: false,      # controls whether to look for patterns in a directory
recursively
  output\_directory: "#{RGen.root}/output/patterns/bin",
  pinmap\_workbook: "#{RGen.root}/output/patterns/atp/fslbist/Pins.txt",
  opcode\_mode: 'dual',
  comments: true
}
compiler = Testers::LinuxPatternCompiler.new(:fslbist, bist\_options)
compiler.find\_jobs # Find all patterns at options[:path] and create compiler jobs
compiler.run # Run the compiler using the jobs queue built by 'find\_jobs' method
~~~

Users can view the compiler job queue by doing the following:

~~~ruby
compiler.inspec\_jobs

| Job:       1 |          Pattern: ls2080\_lnx\_07p2p1\_idreg.atp                            
|
|              |     Pattern type: cmd\_line                                               
|
|              |           Pinmap:
/proj/b4860/b07507/ls2085/rev1.0.0dev3/output/programs/ls2080\_pins.txt                    
|
|              |   .atp directory:
/proj/b4860/b07507/ls2085/rev1.0.0dev3/output/patterns/atp/ltg                            
|
|              |   .pat directory:
/proj/b4860/b07507/ls2085/rev1.0.0dev3/output/patterns/bin/ltg                            
|
|              |              LSF: true                                                   
|
|              | Delete log files: false                                                  
|
|              |    Compiler args: -opcode\_mode:single                                    
|
------------------------------------------------------------------------------------------
---------------------------------------------

~~~

Users can view the current state of the compiler by doing the following:

~~~ruby
compiler.inspect

|            Option            |                                       Argument           
| Required |
------------------------------------------------------------------------------------------
----------------------------------------
| path                         | output/patterns/atp/ltg                                  
|   true   |
| reference\_dir                |
/proj/b4860/b07507/ls2085/rev1.0.0dev3/output/patterns/atp                           |  
false  |
| recursive                    | false                                                    
|   false  |
| compiler                     |
/proj/b4860/b07507/ls2085/.rev1.0.0dev3\_imports\_DO\_NOT\_HAND\_MODIFY/testers/bin/atpc\_Linux6
4\_til/bin/atpcompiler|   true   |
| pattern\_type                 | cmd\_line                                                 
|   true   |
| pinmap\_workbook              |
/proj/b4860/b07507/ls2085/rev1.0.0dev3/output/programs/ls2080\_pins.txt               |  
true   |
| location                     | lsf                                                      
|   false  |
| clean                        | false                                                    
|   false  |
| output\_directory             |
/proj/b4860/b07507/ls2085/rev1.0.0dev3/output/patterns/bin                           |  
false  |
| opcode\_mode                  | single                                                   
|   false  |

~~~

Users can save a compiler job queue by creating a pattern list which can then be run at a
later time.

~~~ruby
compiler.to\_list(name: 'test', output\_directory: '~', force: true, expand: true)

options = {
        name: nil,
        directory: Dir.pwd,
        clean: false,
        location: 'local'
      }.update\_common(list\_options)
~~~

~~ruby
      options = {
        name: @pattern\_type,
        output\_directory: Dir.pwd,
        expand: true,
        force: false
      }.update\_common(options)
~~~

The compiler can handle individual .atp, .atp.gz, .list files or a directory which can be
parsed recursively or flat.

By allowing the users to instantiate a particular type of compiler for each pattern type
that has unique
compiler options required, standardization is enforced.

By allowing the users to send files or directories to the compiler inside of any Ruby
loop/enumeration the user has
much more flexibility in what get sent to the job queue vs. running strictly on the
command line.


<a class="anchor release_tag" name="v0_2_0_dev10"></a>
<h2><a href="#v0_2_0_dev10">Tag: v0.2.0.dev10</a></h2>

##### Branch: 'Trunk'

##### by Daniel Hadad on 14-Oct-2014 16:39PM



#### Changes in this release

- Updated program command used in examples to use prod.list file-- to force
  order of execution causing fewer problems in failing 'rgen examples'.
- Added improved instruments management method to handle MTO (J750) and DCVS
  (UF) instrument argument handling at start of pattern.  Added appropriate
  test case patterns.
- Added forcing of checking that 'rgen examples' passes prior to any new
  release.
- Removed force fail when generating MTO patterns for UF.  Currently doesn't
  have MTO capability yet but coming soon...

#### Known issues:

- Running multiple targets back to back for program generation across different testers giving issue.  Only impacts 'rgen examples' command but needs to be fixed soon.
- Does not support proper placement of stv on multi-cycle JTAG patterns (neither does RGen core Tester class) yet
- Added concept of Pattern subroutine sheets to code-- not yet fully supported.
  
#### Checkouts performed:

- rgen examples (now will always have to pass)

#### Features not yet supported:

- Program Parsing
- V93K support
- UF MTO support


#### NOTE: Debugger 'testers' not included in this app, please see 'Debuggers' plug-in.


<a class="anchor release_tag" name="v0_2_0_dev9"></a>
<h2><a href="#v0_2_0_dev9">Tag: v0.2.0.dev9</a></h2>

##### Branch: 'Trunk'

##### by Brian Caquelin on 10-Oct-2014 16:34PM


updated linux pattern compiler to use single file, pattern list, or directory (flat or
recusive).

Command line args have changed slightly:

~~~ruby

  opts.on("-f", "--file DIR|PATTERN|LIST", "Pattern directory, individual pattern, or
pattern list to be compiled.  Required.") { |path| options[:path] = path }
  opts.on("-p", "--pinmap PINMAP", "Path and filename for the pinmap to be used.
Required.") { |pinfile| options[:pinmap] = pinfile }
  opts.on("-o", "--output DIRECTORY", "Path to the directory to place compiled .PAT
files") { |dir| options[:output] = dir }
  opts.on("-c", "--clean", "Deleted .log files after compilation") {|a|
options[:clean]=true}
  opts.on("-t", "--target TARGET", "Temporarily changes target to TARGET for this
command") { |tar| options[:target] = tar }
  opts.on("-l", "--lsf", "Submit job to the LSF") { |a| options[:lsf] = true}
  opts.on("-r", "--rec", "Do a recursive directory search for patterns if the '-f' arg is
a directory") { |r| options[:rec] = true }
  opts.on\_tail("-h", "--help", "Show this message") { puts opts; exit }

~~~


<a class="anchor release_tag" name="v0_2_0_dev8"></a>
<h2><a href="#v0_2_0_dev8">Tag: v0.2.0.dev8</a></h2>

##### Branch: 'Trunk'

##### by Thao Huynh on 08-Oct-2014 14:03PM


* Added MTO Template generation for J750 Only

<a class="anchor release_tag" name="v0_2_0_dev7"></a>
<h2><a href="#v0_2_0_dev7">Tag: v0.2.0.dev7</a></h2>

##### Branch: 'Trunk'

##### by Jiang Liu on 30-Sep-2014 00:13AM


Merged Priyavadan's changes to latpc.atp for supporting linux ultra-flex pattern compiler.
Added DCVS instrument import to ultra-flex patterns to allow for pattern run-time voltage
switching via PSets.

<a class="anchor release_tag" name="v0_2_0_dev6"></a>
<h2><a href="#v0_2_0_dev6">Tag: v0.2.0.dev6</a></h2>

##### Branch: 'Trunk'

##### by Cory Maughmer on 11-Aug-2014 19:22PM


-Added Teradyne UltraFLEX ATP compiler to plugin, found under /bin
-Added 'latpc' as a shared command for use in applications. See rgen latpc -h for more
help. Only compatible with UF tester
-Use $tester.pattern\_compiler\_pinmap or the -p option at command line to specify the
pinmap to use for compilation of .atp files
-Compiles all .atp files in the default output directory by default. You can specify a
different directory with the -dir option, and also list specific .atp files for
compilation instead of the entire directory.

<a class="anchor release_tag" name="v0_2_0_dev5"></a>
<h2><a href="#v0_2_0_dev5">Tag: v0.2.0.dev5</a></h2>

##### Branch: 'Trunk'

##### by Daniel Hadad on 18-Jul-2014 11:50AM



#### Changes in this release

- Updated to use min rgen core v2.3.0.dev90 to support proper padding of
  UltraFLEX small patterns to 64 vector minimum.
- Added capability to OR 2 flags together based on Test IDs.  Now if flow you
  can do:

~~~ruby

log '"Run testme only if passcode neither present in location A or location
B"'
func :check\_locationA, continue: true, id: :locA
func :check\_locationB, continue: true, id: :locB
nop
log '"OR to set a third master flag"'
# BE SURE to indicate condition (:pass/:fail) to align to where used below since no pass/fail column used
# need to deeper fix to handle automatically
or\_ids id1: :locA, id2: :locB, id: :do\_testme, condition: :pass
func :testme, if\_passed: :do\_testme  # will run only if do\_testme is true--
which only will happen if both passcodes above fail.
~~~

 - Added more opcode cases for flag management.
 - Added :pattern\_timeout as alias for :wait\_time for J750 functional tests.

#### Known issues:

- Running multiple targets back to back for program generation across different testers giving issue.  Only impacts 'rgen examples' command but needs to be fixed soon.
- Does not support proper placement of stv on multi-cycle JTAG patterns (neither does RGen core Tester class) yet
- Added concept of Pattern subroutine sheets to code-- not yet fully supported.
  
#### Checkouts performed:

- rgen examples

#### Features not yet supported:

- Program Parsing
- V93K support

#### NOTE: Debugger 'testers' not included in this app, please see 'Debuggers' plug-in.


<a class="anchor release_tag" name="v0_2_0_dev4"></a>
<h2><a href="#v0_2_0_dev4">Tag: v0.2.0.dev4</a></h2>

##### Branch: 'Trunk'

##### by Daniel Hadad on 23-Jun-2014 14:07PM



#### Changes in this release

- Bugfix: Updated use-limit code to handle setting bins and other info properly for
  UltraFlex as before wouldn't bin.

#### Known issues:

- Running multiple targets back to back for program generation across different testers giving issue.  Only impacts 'rgen examples' command but needs to be fixed soon.
- Does not support proper placement of stv on multi-cycle JTAG patterns (neither does RGen core Tester class) yet
- Added concept of Pattern subroutine sheets to code-- not yet fully supported.
  
#### Checkout performed:

- rgen lint -e
- rgen examples


#### Features not yet supported:

- Program Parsing
- V93K support
- UF flows do not yet support 'Use-Limit' opcode in flow.

#### NOTE: Debugger 'testers' not included in this app, please see 'Debuggers' plug-in.


<a class="anchor release_tag" name="v0_2_0_dev3"></a>
<h2><a href="#v0_2_0_dev3">Tag: v0.2.0.dev3</a></h2>

##### Branch: 'Trunk'

##### by Jiang Liu on 08-May-2014 22:14PM


Messed up the ultraflex\_interface.rb file on previous release, the use limit features are
now correctly added, passing specs and examples.

<a class="anchor release_tag" name="v0_2_0_dev2"></a>
<h2><a href="#v0_2_0_dev2">Tag: v0.2.0.dev2</a></h2>

##### Branch: 'Trunk'

##### by Jiang Liu on 08-May-2014 17:11PM


Added Use\_limit in flow.rb
Added aliases for hilim and lolim
Added :use\_limit for DEFAULTS in flow\_line.rb
Added conditioning to ALIASES.each.do
Added alias\_method for :para in j750\_interface.rb
Added test flow file for testing measurement capability using limits.

<a class="anchor release_tag" name="v0_2_0_dev1"></a>
<h2><a href="#v0_2_0_dev1">Tag: v0.2.0.dev1</a></h2>

##### Branch: 'Trunk'

##### by Daniel Hadad on 11-Apr-2014 15:21PM



### Changes in this release

- UltraFlex templates added for Functional, Other and Empty.
- Updated to support instance, patset and flows for UltraFlex.
- Cleaned up code using new 'rgen lint' feature. 

#### Known issues:

- Running multiple targets back to back for program generation across different testers giving issue.  Only impacts 'rgen examples' command but needs to be fixed soon.
- Does not support proper placement of stv on multi-cycle JTAG patterns (neither does RGen core Tester class) yet
- Added concept of Pattern subroutine sheets to code-- not yet fully supported.
  
### Features not yet supported:

- Program Parsing
- V93K support
- UF flows do not yet support 'Use-Limit' opcode in flow.

### NOTE: Debugger 'testers' not included in this app, please see 'Debuggers' plug-in.


<a class="anchor release_tag" name="v0_2_0_dev0"></a>
<h2><a href="#v0_2_0_dev0">Tag: v0.2.0.dev0</a></h2>

##### Branch: 'Trunk'

##### by Daniel Hadad on 02-Apr-2014 15:23PM



### Changes in this release

- UF program generation capability added
- References to tester templates corrected when accessed from app outside of plug-in.

#### Known issues:

- Running multiple targets back to back for program generation
  across different testers giving issue.  Only impacts
  'rgen examples' command but needs to be fixed soon.


###RGen Core Tester features supported and correlated thus far

####J750 Pattern Generation

- All patterns correlated except:
    - Does not support stv on multi-cycle JTAG patterns (neither does RGen core
      Tester class) yet
    - Minor difference in match loop implementation (extra clr\_fail when loop completed)
  
#### J750 Program Generation

- All differences correlate

#### UltraFlex Program Generation

- Can generate instancen, flow, patset sheets with proper header info.
- Still not valid arguments and template types for UF.


#### UltraFlex Pattern Generation

- Does not support stv on multi-cycle JTAG patterns yet
- Match loops checked on tester!
- Handshake methodology checked on tester!

###RGen Core features not yet supported:

- Program Parsing
- V93K support

###NOTE: Debugger 'testers' not included in this app, please see 'Debuggers' plug-in.


<a class="anchor release_tag" name="v0_2_0"></a>
<h1><a href="#v0_2_0">Tag: v0.2.0</a></h1>

##### Branch: 'Trunk'

##### by Daniel Hadad on 24-Mar-2014 16:33PM


Updated match loops for J750 and UltraFlex to count cycles of a block of code
used for match conditions automatically, and adjust loops/counters
accordingly.

Will very large timeout values:

 - For J750, max timeout = 2^32 * period * num\_cycles\_to\_match
 - For UltraFLEX = 2^44 * period * num\_cycles\_to\_match

Where num\_cycles\_to\_match is number of cycles per match loop iteration, which 
includes delays to flush pipeline on each iteration.

E.G. for 60nS period UTI pattern on J750, max timeout => 158min
E.G. for 60nS period UTI pattern on UltraFLEX, max timeout => 1116min
E.G. for 250nS period Nexus pattern on J750, max timeout => 3758 min

For all purposes there is no limit.

For J750 match loop timeout is implemented using 2 16-bit counters nested.

For UltraFLEX match loop timeout is implemented using 1 28-bit counter with
additional delay added via repeat count.

<a class="anchor release_tag" name="v0_1_0"></a>
<h1><a href="#v0_1_0">Tag: v0.1.0</a></h1>

##### Branch: 'Trunk'

##### by Daniel Hadad on 14-Mar-2014 15:55PM


First semi-official release of Testers plug-in.

###RGen Core features supported and correlated:
####J750 Pattern Generation

- Does not support stv on multi-cycle JTAG patterns (neither does RGen core
  Tester class) yet
- Minor difference in match loop implementation (extra clr\_fail when loop completed)
  
#### J750 Program Generation
- All differences correlate

#### UltraFlex Pattern Generation
- Does not support stv on multi-cycle JTAG patterns yet
- Improved UF support over RGen core Tester class
- Match loops not yet checked on tester
- Handshake methodology not yet checked on tester

###RGen Core features not yet supported:

- UltraFlex Program Generation
- Program Parsing
- V93K support

###NOTE: Debugger 'testers' not included in this app, please see 'Debuggers' plug-in.


<a class="anchor release_tag" name="v0_0_0_dev2"></a>
<h2><a href="#v0_0_0_dev2">Tag: v0.0.0.dev2</a></h2>

##### Branch: 'Trunk'

##### by Daniel Hadad on 03-Mar-2014 17:18PM


Added program generation capability for J750 and J750\_HPT. Output matches
against program generation examples from RGen core.

Updated 'examples' command to include both pattern and proggen checking
capability.

<a class="anchor release_tag" name="v0_0_0_dev1"></a>
<h2><a href="#v0_0_0_dev1">Tag: v0.0.0.dev1</a></h2>

##### Branch: 'Trunk'

##### by Daniel Hadad on 13-Feb-2014 10:55AM


Added vector padding capability if tester has fewer than some limit.  Default
is 0 (J750). 

Mainly to support ultraflex which requires 64 min vectors for a VM module in single
mode (128 in dual mode).  Added reset pattern test to check this.

<a class="anchor release_tag" name="v0_0_0_dev0"></a>
<h2><a href="#v0_0_0_dev0">Tag: v0.0.0.dev0</a></h2>

##### Branch: 'Trunk'

##### by Daniel Hadad on 10-Feb-2014 14:14PM


Initial release of Testers plug-in.
Currently works only for pattern generation for J750 and J750\_HPT testers.
Will working to correlate all code aspects for J750/J750\_HPT.
./



